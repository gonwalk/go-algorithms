动态规划问题总结

# 动态规划

# 1.1 动态规划定义

首先，我们看一下官方定义:
```
动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。
```

## 1.2 动态规划思想

### 1.2.1 基本思想

动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。

基本思想与策略编辑:
由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个数组中。


首先是拆分问题，就是根据问题的可能性把问题划分成几个子问题，就可以通过递推或者递归来实现。
动态规划有一类问题是从后往前推导，有时候我们很容易知道：如果只有一种情况时，最佳的选择应该怎么做。然后根据这个最佳选择往前一步推导，得到前一步的最佳选择。然后就是定义问题状态和状态之间的关系，用一种量化的形式表现出来，类似于高中学的推导公式，也就是最后所说的状态转移方程式。

当找到最优解，应该将最优解保存下来，为了往前推导时能够使用前一步的最优解，在这个过程中难免有一些相比于最优解差的解，此时我们应该放弃，只保存最优解，这样每一次都把最优解保存了下来，大大降低了时间复杂度。

### 1.2.2 动态规划的三大步骤

参考：
告别动态规划，连刷 40 道题，我总结了这些套路，看不懂你打我（万字长文）
https://zhuanlan.zhihu.com/p/91582909

动态规划，无非就是利用历史记录，来避免我们的重复计算。而这些历史记录，我们得需要一些变量来保存，一般是用一维数组或者二维数组来保存。下面我们先来讲下做动态规划题很重要的三个步骤，

```
第一步骤：定义数组元素的含义，用一个数组，来保存历史数组（一维或二维），假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是定义这个数组元素的含义，例如你的 dp[i] 是代表什么意思？

第二步骤：找出数组元素之间的关系式，对于动态规划的这一步，还是有一点类似于我们高中学习时的归纳法的，当我们要计算 dp[n] 时，可以利用 dp[n-1]，dp[n-2].....dp[1]来推出 dp[n] ，也就是可以利用历史数据来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步。

第三步骤：找出初始值。学过数学归纳法的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是需要知道初始值才能得到具体的结果。例如，一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 不能再分解的了，就需要通过题意直接获得 dp[2] 和 dp[1] 的值，而这，就是所谓的初始值。
```

有了初始值和数组元素之间的关系式，接下来就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想求什么，就定义它是什么，这样，这道题也就解出来了。

## 1.3 案例详解

### 1.3.1 案例一、简单的一维 DP

问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

(1)、定义数组元素的含义
按我上面的步骤说的，首先我们来定义 dp[i] 的含义，我们的问题是要求青蛙跳上 n 级的台阶总共由多少种跳法，那我们就定义 dp[i] 的含义为：跳上一个 i 级的台阶总共有 dp[i] 种跳法。这样，如果我们能够算出 dp[n]，不就是我们要求的答案吗？所以第一步定义完成。

（2）、找出数组元素间的关系式
我们的目的是要求 dp[n]，动态规划的题，如你们经常听说的那样，就是把一个规模比较大的问题分成几个规模比较小的问题，然后由小的问题推导出大的问题。也就是说，dp[n] 的规模为 n，比它规模小的是 n-1, n-2, n-3.... 也就是说，dp[n] 一定会和 dp[n-1], dp[n-2]....存在某种关系的。我们要找出他们的关系。

那么问题来了，怎么找？

这个怎么找，是最核心最难的一个，我们必须回到问题本身来了，来寻找他们的关系式，dp[n] 究竟会等于什么呢？

对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式
```
一种是从第 n-1 级跳上来

一种是从第 n-2 级跳上来
```
由于我们是要算所有可能的跳法的，所以有 dp[n] = dp[n-1] + dp[n-2]。

（3）、找出初始条件
当 n = 1 时，dp[1] = dp[0] + dp[-1]，而我们是数组是不允许下标为负数的，所以对于 dp[1]，我们必须要直接给出它的数值，相当于初始值，显然，dp[1] = 1。一样，dp[0] = 0.（因为 0 个台阶，那肯定是 0 种跳法了）。于是得出初始值：

dp[0] = 0. dp[1] = 1. 即 n <= 1 时，dp[n] = n.

三个步骤都做出来了，那么我们就来写代码吧，代码会详细注释滴。
```
int f( int n ){
    if(n <= 1)
    return n;
    // 先创建一个数组来保存历史数据
    int[] dp = new int[n+1];
    // 给出初始值
    dp[0] = 0;
    dp[1] = 1;
    // 通过关系式来计算出 dp[n]
    for(int i = 2; i <= n; i++){
        dp[i] = dp[i-1] + dp[i-2];
    }
    // 把最终结果返回
    return dp[n];
}
```
（4）、再说初始化
大家先想以下，你觉得，上面的代码有没有问题？

答是有问题的，还是错的，错在对初始值的寻找不够严谨，这也是我故意这样弄的，意在告诉你们，关于初始值的严谨性。例如对于上面的题，当 n = 2 时，dp[2] = dp[1] + dp[0] = 1。这显然是错误的，你可以模拟一下，应该是 dp[2] = 2。

也就是说，在寻找初始值的时候，一定要注意不要找漏了，dp[2] 也算是一个初始值，不能通过公式计算得出。有人可能会说，我想不到怎么办？这个很好办，多做几道题就可以了。

下面我再列举三道不同的例题，并且，再在未来的文章中，我也会持续按照这个步骤，给大家找几道有难度且类型不同的题。下面这几道例题，不会讲的特性详细哈。实际上 ，上面的一维数组是可以把空间优化成更小的，不过我们现在先不讲优化的事，下面的题也是，不讲优化版本。

### 1.3.2 案例二：二维数组的 DP

可以说，80% 的DP的算法题，都是要用二维数组的，所以下面的题主要以二维数组为主，当然有人可能会说，要用一维还是二维，我怎么知道？这个问题不大，接着往下看。

问题描述

一个机器人位于一个 m x n 网格的左上角，机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角，问总共有多少条不同的路径？

这是 leetcode 的 62 号题：https://leetcode-cn.com/problems/unique-paths/
还是老样子，三个步骤来解决。

步骤一、定义数组元素的含义
由于我们的目的是从左上角到右下角一共有多少种路径，那我们就定义 dp[i] [j]的含义为：当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i] [j] 种路径。那么，dp[m-1] [n-1] 就是我们要的答案了。

注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 dp[m-1] [n-1] 就是我们要找的答案。
步骤二：找出关系数组元素间的关系式
想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达

一种是从 (i-1, j) 这个位置走一步到达

一种是从(i, j - 1) 这个位置走一步到达

因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]。

步骤三、找出初始值
显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：

dp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往左走

dp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走


注意：
起点是左上角,也就是坐标 (0,0)的地方!终点是右下角坐标是 (m,n)的地方!
只能往右和往下移动,不能左转,也不能斜着对角走
思路:

从终点看，到(m,n)的路径要么从(m-1,n)，设为A点（再往右走一步）；要么从 (m,n-1)，设为B点（往下走一步即到终点），这两个地方来。
那么到终点可能的路径就是 起点到A点的路径 + 起点到B点的路径。
那么A点路径的个数是多少呢，是它左边的路径 + 它上面的路径。
...
一直拆分到 原点

代码:
```go
func uniquePaths(m int, n int) int {
    if(m <= 0 || n <= 0) {
        return 0
    }

    // 二维数组的一种声明方式
    dp := make([][]int, m)          // 声明一个m维的数组，存放中间结果
    for i, _ := range dp {
        dp[i] = make([]int, n)      // dp的每个维度又是一个长度为n的一维数组
    }
    for i := 1; i < m; i++ {
        dp[i][0] = 1                // 第0列只有一条路径
    }

    for i := 0; i < n; i++ {
        dp[0][i] = 1                // 第0行
    }

    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {
            dp[i][j] = dp[i][j-1] + dp[i-1][j]
        }
    }
    return dp[m-1][n-1]
}
```

O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的，不过这里先不讲

### 1.3.3 案例三、二维数组 DP

问题描述：
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

举例：
输入:
arr = [
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。
和上面的差不多，不过是算最优路径和，这是 leetcode 的第64题：https://leetcode-cn.com/problems/minimum-path-sum/


步骤一、定义数组元素的含义
由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp[i][j]的含义为：当机器人从左上角走到(i, j) 这个位置时，最下的路径和是 dp[i][j]。那么，dp[m-1][n-1] 就是我们要的答案了。

注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以最右下标的位置是 (m-1, n-1)，则 dp[m-1][n-1] 就是我们要找的答案。

步骤二：找出关系数组元素间的关系式
想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达

一种是从 (i-1, j) 这个位置走一步到达

一种是从(i, j-1) 这个位置走一步到达

不过这次不是计算所有可能路径，而是计算哪一个路径和是最小的，那么我们要从这两种方式中，选择一种，使得dp[i][j] 的值是最小的，显然有

dp[i][j] = min(dp[i-1][j]，dp[i][j-1]) + arr[i][j];    // arr[i][j] 表示网格种的值

步骤三、找出初始值
显然，当 dp[i][j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题，所以我们的初始值是计算出所有的 dp[0][0….n-1] 和所有的 dp[0….m-1][0]，相当于最上面一行和左边一列。因此初始值如下：
```
dp[0][j] = arr[0][j] + dp[0][j-1];  // 相当于最上面一行，机器人只能一直往左走

dp[i][0] = arr[i][0] + dp[i-1][0];  // 相当于最左面一列，机器人只能一直往下走
```
代码实现：
```golang
func minPathSum(grid [][]int) int {
    m, n := len(grid), len(grid[0]) // m和n分别表示行列数
    dp := make([][]int, m)         // 二维数组dp，用于存放到当前位置的最小路径和
    for i, _ := range dp {
        dp[i] = make([]int, n)      // 为二维数组的每一维声明一个长度
    }

    if(m <= 0 || n <= 0) {          // 行列长度中有一个为0，就构不成二维数组
        return 0
    }
    dp[0][0] = grid[0][0]           // 初始化起点的最短路径为本身
    for i := 1; i < m; i++ {        // 第0列，注意i-1>=0，所以i从1开始，同时dp[0][0]需要初始化
        dp[i][0] = dp[i-1][0] + grid[i][0]  // 最左一列，只能往下走
    }
    for i := 1; i < n; i++ {        // 第0行
        dp[0][i] = dp[0][i-1] + grid[0][i]  // 最上一行，只能往右走
    }
    
    for i := 1; i < m; i++ {
        for j := 1; j < n; j++ {    // 其他行列，当前最短路径dp[i][j]为dp[i-1][j]和dp[i][j-1]中的最小值加上当前点的长度
            dp[i][j] = minInt(dp[i][j-1], dp[i-1][j]) + grid[i][j]
        }
    }
    return dp[m-1][n-1]
}

func minInt(i, j int) int {
    if(i < j) {
        return i 
    } else {
        return j
    }
}
```

O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的，不过这里先不讲

### 1.3.4 案例 4：编辑距离

leetcode 的第 72 号题，这道题比上面的难一些，在 leetcode上的定位是 hard 级别。

#### 1.3.4.1 问题描述

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符、 删除一个字符、 替换一个字符

示例：
输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')

#### 1.3.4.2 解题步骤

还是老样子，按照上面三个步骤来，并且我这里可以告诉你，90% 的字符串问题都可以用动态规划解决，并且90%是采用二维数组。

步骤一、定义数组元素的含义：

由于我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 dp[i][j]的含义为：当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i][j]。

有时候，数组的含义并不容易找，所以还是那句话，我给你们一个套路，剩下的还得看你们去领悟。

步骤二：找出数组元素间的关系式

接下来我们就要找 dp[i][j] 元素之间的关系了，比起其他题，这道题相对比较难找一点，但是，不管多难找，大部分情况下，dp[i][j] 和 dp[i-1][j]、dp[i][j-1]、dp[i-1][j-1] 肯定存在某种关系。因为我们的目标就是，从规模小的，通过一些操作，利用之前的记录，推导出规模大的问题的解。对于这道题，我们可以对 word1 进行三种操作：
插入一个字符、 删除一个字符、 替换一个字符。

由于我们是要让操作的次数最小，所以我们要寻找最佳操作。那么有如下关系式：
```
一、如果 word1[i] 与 word2[j] 相等，即长度为i的字符串word1与长度为j的字符串word2相等，这个时候不需要进行任何操作，显然有 dp[i][j] = dp[i-1][j-1]（由word1[i] = word2[j]推导出来的）。

二、如果 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系式如下（注意字符串与字符的区别）：

（1）、如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i][j] = dp[i-1][j-1] + 1（即由长度为i-1的word1和长度为j-1的字符串word2经过一次替换操作就可以转换为长度为i的word1和长度为j的word2）。

（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i][j] = dp[i][j-1] + 1;

（3）、如果把字符 word1[i] 删除，则有 dp[i][j] = dp[i-1][j] + 1;
```
从上面的分析中，需要选择一种操作，使得 dp[i][j] 的值最小，显然有
```
dp[i][j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;
```
于是，关系式就推出来了。

步骤三、找出初始值

显然，当 dp[i][j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题，所以初始值是计算出所有的 dp[0] [0….n] 和所有的 dp[0….m] [0]。当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。

#### 1.3.4.3 代码实现
```go
func minDistance(word1 string, word2 string) int {
    l1 := len(word1)
    l2 := len(word2)        // 两个字符串长度
    dp := make([][]int, l1 + 1)            // 为了存放下dp[i][j]需要开辟l1+1行，l2+1列
    if(l1 <= 0 || l2 <= 0) { 
        return maxInt(l1, l2)              // 有一个为空字符串，返回另一个不为空的长度（插入或删除这个次）
    }
    for i := 0; i <= l1; i++  {
        dp[i] = make([]int, l2 + 1)            // 为dp[l1+1][]的每个维度声明l2 + 1个列
    }
    dp[0][0] = 0
    for i := 1; i <= l1; i++ {               // 有一个字符串长度为0，那么只需要将另一个字符串中的字符逐个插入或者删除字符即可
        dp[i][0] = dp[i-1][0] + 1
    }

    for i := 1; i <= l2; i++ {              // 注意，能取到等于l2
        dp[0][i] = dp[0][i-1] + 1
    }

    for i := 1; i <= l1; i++ {
        for j := 1; j <= l2; j++ {
            if(word1[i-1] == word2[j-1]) {  // 当前字符相同，
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = minInt(minInt(dp[i-1][j-1], dp[i-1][j]), dp[i][j-1]) + 1
            }
        }
    }
    return dp[l1][l2]
}

func minInt(i, j int) int {
    if(i < j) {
        return i 
    } else {
        return j
    }
}

func maxInt(i, j int) int {
    if(i < j) {
        return j 
    } else {
        return i
    }
}
``` 

最后说下，如果你要练习，可以去 leetcode，选择动态规划专题，然后连续刷几十道，保证你以后再也不怕动态规划了。

Leetcode 动态规划直达：https://leetcode-cn.com/tag/dynamic-programming/


## 1.4 如何优化


使用动态规划的基本套路，通常情况下是可以进一步优化的。而优化的核心：可以通过画图去比较，找到优化的途径。

没错，80% 的动态规划题都可以画图，其中 80% 的题都可以通过画图一下子知道怎么优化，当然，DP 也有一些很难的题，想优化可没那么容易。不过，这里要讲的，是属于不怎么难，且最常见，面试笔试最经常考的难度的题。

下面我们直接通过三道题目来讲解优化，你会发现，这些题，优化过后，代码只有细微的改变，你只要会一两道，可以说是会了 80% 的题。

O(n*m) 空间复杂度优化成 O(n)
上面那个跳台阶的 dp 题可以把空间复杂度 O(n) 优化成 O(1)，这里从二维数组的 dp 讲起。

### 1.4.1 案例1：最多路径数

问题描述：

一个机器人位于一个 m x n 网格的左上角。

机器人每次只能向下或者向右移动一步，机器人试图达到网格的右下角，问总共有多少条不同的路径？

这是 leetcode 的 62 号题：https://leetcode-cn.com/problems/unique-paths/

这道题的 dp 转移公式是 dp[i][j] = dp[i-1][j] + dp[i][j-1]
```java
public static int uniquePaths(int m, int n) {
    if (m <= 0 || n <= 0) {
        return 0;
    }

    int[][] dp = new int[m][n]; // 
    // 初始化
    for(int i = 0; i < m; i++){
      dp[i][0] = 1;
    }
    for(int i = 0; i < n; i++){
      dp[0][i] = 1;
    }
        // 推导出 dp[m-1][n-1]
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
}
```

这种做法的空间复杂度是 O(n * m)，下面我们来讲解如何优化成 O(n)。
dp[i][j] 是一个二维矩阵，我们来画个二维矩阵的图，对矩阵进行初始化


然后根据公式 dp[i][j] = dp[i-1][j] + dp[i][j-1] 来填充矩阵的其他值。下面我们先填充第二行的值。


大家想一个问题，当我们要填充第三行的值的时候，我们需要用到第一行的值吗？答是不需要的，不信你试试，当你要填充第三，第四....第 n 行的时候，第一行的值永远不会用到，只有在填充第二行的值时会用到（第一行的值）。

根据公式 dp[i][j] = dp[i-1][j] + dp[i][j-1]，我们可以知道，当我们要计算第 i 行的值时，除了会用到第 i - 1 行外，其他第 1 至 第 i-2 行的值都是不需要用到的，也就是说，对于那部分用不到的值我们还有必要保存他们吗？

答：没必要，我们只需要用一个一维的 dp[] 来保存一行的历史记录就可以了。然后在计算的过程中，不断地更新 dp[] 的值。单说估计你可能不好理解，下面我就手把手来演示下这个过程。

1、刚开始初始化第一行，此时 dp[0..n-1] 的值就是第一行的值。

2、接着我们来一边填充第二行的值一边更新 dp[i] 的值，一边把第一行的值抛弃掉。

为了方便描述，下面我们用arr (i，j）表示矩阵中第 i 行 第 j 列的值。从 0 开始哈，就是说有第 0 行。
（1）、显然，矩阵(1, 0) 的值相当于以往的初始化值，为 1。然后这个时候矩阵 (0，0）的值不在需要保存了，因为再也用不到了。


这个时候，我们也要跟着更新 dp[0] 的值了，刚开始 dp[0] = (0, 0)，现在更新为 dp[0] = (1, 0)。

（2）、接着继续更新 (1, 1) 的值，根据之前的公式 （i, j) = (i-1, j) + (i, j- 1)。即 （1，1）=（0，1）+（1，0）=2。


大家看图，以往的二维的时候， dp[i][j] = dp[i-1] [j]+ dp[i][j-1]。现在转化成一维，不就是 dp[i] = dp[i] + dp[i-1] 吗？

即 dp[1] = dp[1] + dp[0]，而且还动态帮我们更新了 dp[1] 的值。因为刚开始 dp[i] 的保存第一行的值的，现在更新为保存第二行的值。


(3)、同样的道理，按照这样的模式一直来计算第二行的值，顺便把第一行的值抛弃掉，结果如下


此时，dp[i] 将完全保存着第二行的值，并且我们可以推导出公式

dp[i] = dp[i-1] + dp[i]

dp[i-1] 相当于之前的 dp[i-1][j]，dp[i] 相当于之前的 dp[i][j-1]。
于是按照这个公式不停着填充到最后一行，结果如下：


最后 dp[n-1] 就是我们要求的结果了。所以优化之后，代码如下：

public static int uniquePaths(int m, int n) {
    if (m <= 0 || n <= 0) {
        return 0;
    }

    int[] dp = new int[n]; // 
    // 初始化
    for(int i = 0; i < n; i++){
      dp[i] = 1;
    }

        // 公式：dp[i] = dp[i-1] + dp[i]
    for (int i = 1; i < m; i++) {
        // 第 i 行第 0 列的初始值
        dp[0] = 1;
        for (int j = 1; j < n; j++) {
            dp[j] = dp[j-1] + dp[j];
        }
    }
    return dp[n-1];
}

### 1.4.2 案例2：编辑距离
接着我们来看昨天的另外一道题，就是编辑矩阵，这道题的优化和这一道有一点点的不同，上面这道 dp[i][j] 依赖于 dp[i-1][j] 和 dp[i][j-1]。而还有一种情况就是 dp[i][j] 依赖于 dp[i-1][j]，dp[i-1][j-1] 和 dp[i][j-1]。

问题描述

给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符 删除一个字符 替换一个字符

示例：
输入: word1 = "horse", word2 = "ros"
输出: 3
解释: 
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
解答

昨天的代码如下所示，不懂的记得看之前的文章哈：告别动态规划，连刷40道动规算法题，我总结了动规的套路

public int minDistance(String word1, String word2) {
    int n1 = word1.length();
    int n2 = word2.length();
    int[][] dp = new int[n1 + 1][n2 + 1];
    // dp[0][0...n2]的初始值
    for (int j = 1; j <= n2; j++) 
        dp[0][j] = dp[0][j - 1] + 1;
    // dp[0...n1][0] 的初始值
    for (int i = 1; i <= n1; i++) dp[i][0] = dp[i - 1][0] + 1;
        // 通过公式推出 dp[n1][n2]
    for (int i = 1; i <= n1; i++) {
        for (int j = 1; j <= n2; j++) {
            // 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1
            if (word1.charAt(i - 1) == word2.charAt(j - 1)){
                p[i][j] = dp[i - 1][j - 1];
            }else {
               dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;
            }         
        }
    }
    return dp[n1][n2];  
}
没有优化之间的空间复杂度为 O(n*m)
大家可以自己动手做下，按照上面的那个模式，你会优化吗？


对于这道题其实也是一样的，如果要计算 第 i 行的值，我们最多只依赖第 i-1 行的值，不需要用到第 i-2 行及其以前的值，所以一样可以采用一维 dp 来处理的。

不过这个时候要注意，在上面的例子中，我们每次更新完 (i, j) 的值之后，就会把 (i, j-1) 的值抛弃，也就是说之前是一边更新 dp[i] 的值，一边把 dp[i] 的旧值抛弃的，不过在这道题中则不可以，因为我们还需要用到它。

哎呀，直接举例子看图吧，文字绕来绕去估计会绕晕你们。当我们要计算图中 (i,j) 的值的时候，在案例1 中，我们值需要用到 (i-1, j) 和 (i, j-1)。（看图中方格的颜色）


不过这道题中，我们还需要用到 （i-1, j-1) 这个值（但是这个值在以往的案例1 中，它会被抛弃掉）


所以呢，对于这道题，我们还需要一个额外的变量 pre 来时刻保存 (i-1,j-1) 的值。推导公式就可以从二维的

dp[i][j] = min(dp[i-1][j] , dp[i-1][j-1] , dp[i][j-1]) + 1
转化为一维的

dp[i] = min(dp[i-1], pre, dp[i]) + 1。
所以呢，案例2 其实和案例1 差别不大，就是多了个变量来临时保存。最终代码如下（但是初学者话，代码也没那么好写）

代码如下
public int minDistance(String word1, String word2) {
    int n1 = word1.length();
    int n2 = word2.length();
    int[] dp = new int[n2 + 1];
    // dp[0...n2]的初始值
    for (int j = 0; j <= n2; j++) 
        dp[j] = j;
    // dp[j] = min(dp[j-1], pre, dp[j]) + 1
    for (int i = 1; i <= n1; i++) {
        int temp = dp[0];
        // 相当于初始化
        dp[0] = i;
        for (int j = 1; j <= n2; j++) {
            // pre 相当于之前的 dp[i-1][j-1]
            int pre = temp;
            temp = dp[j];
            // 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1
            if (word1.charAt(i - 1) == word2.charAt(j - 1)){
                dp[j] = pre;
            }else {
               dp[j] = Math.min(Math.min(dp[j - 1], pre), dp[j]) + 1;
            } 
            // 保存要被抛弃的值       
        }
    }
    return dp[n2]; 
}
总结
上面的这些题，基本都是不怎么难的入门题，除了最后一道相对难一点。并且基本 80% 的二维矩阵 dp 都可以像上面的方法一样优化成 一维矩阵的 dp，核心就是要画图，看他们的值依赖，当然，还有很多其他比较难的优化，但是，我遇到的题中，大部分都是我上面这种类型的优化。后面如何遇到其他的，我会作为案例来讲，今天就先讲最普遍最通用的优化方案。记住，画二维 dp 的矩阵图，然后看元素之间的值依赖，然后就可以很清晰着知道该如何优化了。

在之后的文章中，我也会按照这个步骤，在给大家讲四五道动态规划 hard 级别的题，会放在每天推文的第二条给大家学习。如果觉得有收获，不放三连走起来（点赞、感谢、分享），嘻嘻。



经典的数字三角形问题(简单易懂,经典动态规划);
题目:

可以看出每走第n行第m列时有两种后续:向下或者向右下
由于最后一行可以确定,当做边界条件,所以我们自然而然想到递归求解
解题思路:

下面简单写一下java代码:

//java代码纯属自己练习,标准答案参考上面的c语言答案
class solution{
	public int getMax(){
		int MAX = 101;
		int[][] D = new int[MAX][MAX];   //存储数字三角形
		int n;              //n表示层数
		int i = 0; int j = 0;
		int maxSum = getMaxSum(D,n,i,j);
		return maxSum;
	}
	public int getMaxSum(int[][] D,int n,int i,int j){
		if(i == n){
			return D[i][j];
		}
		int x = getMaxSum(D,n,i+1,j);
		int y = getMaxSum(D,n,i+1,j+1);
		return Math.max(x,y)+D[i][j];
	}
}


其实仔细观察,上面的解答过程时间复杂度难以想象的大,那是因为他对有的数字的解进行了多次的重复计算,具体如下图:

如果不明白上图,可以把每条路径都画出来,观察每个数字有多少条路径经过了他,就会一目了然
然后我们就可以自然而然的想到,如果我们每次都把结果保存下来,复杂度就会大大降低

其实答案很简单:
其实这是动态规划很精髓的一部分,是减少复杂度的主要原因
我们都知道,递归一般情况下是可以转化为递推的,不详细解释了,贴上答案:

其实,仔细观察该解题过程,该过程就是标准的动态规划解题过程,如果把该过程画出来(找到每一步的最优解,其他的舍弃)对动态规划会有更深刻的解法
还有就是,递推的另一个好处是可以进行空间优化,如图:

下面总结一下动态规划的解题一般思路:
首先递归应该是我们解决动态规划问题最常用的方法,帅,速度不算太慢
那么递归到动规的一般转化方法为:
如果该递归函数有n个参数,那么就定义一个n维数组,数组下标是递归函数参数的取值范围(也就是数组每一维的大小).数组元素的值就是递归函数的返回值(初始化为一个标志值,表明还未被填充),这样就可以从边界值开始逐步的填充数组,相当于计算递归函数的逆过程(这和前面所说的推导过程应该是相同的).
原文链接:https://blog.csdn.net/ailaojie/article/details/83014821

动规解题的一般思路(标准官方,不过经过前边讲解应该就能理解了):

将原问题分解为子问题(开头已经介绍了怎么分解) (注意:1,子问题与原问题形式相同或类似,只是问题规模变小了,从而变简单了; 2,子问题一旦求出就要保存下来,保证每个子问题只求解一遍)
确定状态(状态:在动规解题中,我们将和子问题相关的各个变量的一组取值,称之为一个"状态",一个状态对应一个或多个子问题所谓的在某个状态的值,这个就是状态所对应的子问题的解,所有状态的集合称为"状态空间".我的理解就是状态就是某个问题某组变量,状态空间就是该问题的所有组变量) 另外:整个问题的时间复杂度就是状态数目乘以每个状态所需要的时间
确定一些初始状态(边界条件)的值 (这个视情况而定,千万别以为就是最简单的那个子问题解,上面只是例子,真正实践动规千变万化)
确定状态转移方程 (这一步和第三步是最关键的 记住"人人为我"递推,由已知推未知)
适合使用动规求解的问题:
1,问题具有最优子结构
2,无后效性 说的花里胡哨的,其实一般遇到求最优解问题一般适合使用动态规划

