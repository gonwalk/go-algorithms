# 1.分发饼干

链接：https://leetcode-cn.com/problems/assign-cookies

## 1.1 问题描述

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。

示例 1:

输入: [1,2,3], [1,1]

输出: 1

解释: 
你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

示例 2:

输入: [1,2], [1,2,3]

输出: 2

解释: 
你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.

## 1.2 算法实现

本题可以使用贪心算法的实现进行解答。

### 1.2.1 算法思路

```
- 给一个孩子的饼干应当尽量小并且又能满足该孩子，这样大饼干才能拿来给满足度比较大的孩子。
- 因为满足度最小的孩子最容易得到满足，所以先满足满足度最小的孩子。
````

在以上的解法中，在每次分配饼干时选择一种看起来是当前最优的分配方法，但无法保证这种局部最优的分配方法最后能得到全局最优解。现假设能得到全局最优解，并使用反证法进行证明，即假设存在一种比现在使用的贪心策略更优的最优策略。如果不存在这种最优策略，表示贪心策略就是最优策略，得到的解也就是全局最优解。

证明：假设在某次选择中，贪心策略选择给当前满足度最小的孩子分配第 m 个饼干，第 m 个饼干为可以满足该孩子的最小饼干。假设存在一种最优策略，可以给该孩子分配第 n 个饼干，并且 m < n。可以发现，经过这一轮分配，贪心策略分配后剩下的饼干一定有一个比最优策略来得大。因此在后续的分配中，贪心策略一定能满足更多的孩子。也就是说不存在比贪心策略更优的策略，即贪心策略就是最优策略。


链接：https://leetcode-cn.com/problems/assign-cookies/solution/tan-xin-jie-fa-by-cyc2018/


### 1.2.2 算法实现

```go
func findContentChildren(g []int, s []int) int {
    var child, cookie int   // child代表已满足几个孩子，cookie表示尝试了几个饼干
    sort.Ints(g)    // 对胃口值从小到大排序
    sort.Ints(s)    // 对饼干值从小到大排序
    for(cookie < len(s) && child < len(g)) {    // child < len(g)不能省略
        if(s[cookie] >= g[child]){
            child++
        }
        cookie++
    }
    return child
}
```

# 2.摆动序列

链接：https://leetcode-cn.com/problems/wiggle-subsequence

## 2.1 题目描述

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。

例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。

示例 1:

输入: [1,7,4,9,2,5]
输出: 6 
解释: 整个序列均为摆动序列。
示例 2:

输入: [1,17,5,10,13,15,10,5,16,8]
输出: 7
解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
示例 3:

输入: [1,2,3,4,5,6,7,8,9]
输出: 2
进阶:
你能否用 O(n) 时间复杂度完成此题?

## 2.2 算法实现

### 2.2.1 算法思路

当序列有一段连续的递增（或递减）时，为形成摇摆子序列，需要保留这段连续的递增（或递减）的首尾元素，这样可以更可能地使得尾部的后一个元素成为摇摆子序列的下一个元素。


### 2.2.2 代码实现
```go
func wiggleMaxLength(nums []int) int {
    begin := 0
    down := 1
    up := 2             // 定义转态
    var maxLen int = 1          // 记录最大摆动序列的长度，注意开始时是从1号下标的元素进行的，所以摆动序列最少为1
    var state int = begin   // 刚开始转态为begin
    if(len(nums) < 2){      // 注意：这里不能等，因为对于只有两个元素且相等的情况[6,6]，其返回2是错误的，应该范围1
        return len(nums)
    }
    for i:= 1; i < len(nums); i++ {
        switch state {
            case begin:     // 从begin可以转到down和up状态
                if(nums[i-1] > nums[i]) {   // 更新状态
                    state = down
                    maxLen++
                }else if(nums[i-1] < nums[i]) {
                    state = up
                    maxLen++
                }
                break       // 前后两个元素相等，不进行状态更新，同时跳出该case，进行下一个元素的比较

            case down:      // 上一个状态是down，则可以从down状态转向up
                if(nums[i-1] < nums[i]) {
                    state = up
                    maxLen++
                }
                break

            case up:        //上一个状态是up，需要从up转向down，继续下一个元素的判断
                if(nums[i-1] > nums[i]){
                    state = down
                    maxLen++    
                }
                break
        }

    }
    return maxLen

} 
```


# 用最少数量的箭引爆气球

来源LeetCode452：https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons

## 题目描述

在二维空间中有许多球形的气球。对于每个气球，提供的输入是水平方向上，气球直径的开始和结束坐标。由于它是水平的，所以y坐标并不重要，因此只要知道开始和结束的x坐标就足够了。开始坐标总是小于结束坐标。平面内最多存在104个气球。

一支弓箭可以沿着x轴从不同点完全垂直地射出。在坐标x处射出一支箭，若有一个气球的直径的开始和结束坐标为 xstart，xend， 且满足  xstart ≤ x ≤ xend，则该气球会被引爆。可以射出的弓箭的数量没有限制。 弓箭一旦被射出之后，可以无限地前进。我们想找到使得所有气球全部被引爆，所需的弓箭的最小数量。

Example:

输入:
[[10,16], [2,8], [1,6], [7,12]]

输出:
2

解释:
对于该样例，我们可以在x = 6（射爆[2,8],[1,6]两个气球）和 x = 11（射爆另外两个气球）。




## 算法实现：贪心算法



### 实现方式一：对气球数组的左侧坐标排序

（1）算法思路：

```markdown
1.对各个气球按照气球的左端坐标进行从小到大排序；
2.遍历气球数组，同时维护一个（当前的）射击区间，在满足可以将当前气球射穿的情况下，尽可能击穿更多的气球（贪心策略），每击穿一个新的气球，更新一次射击区间（保证射击区间可以将新气球也击穿）
3.如果新的气球没办法被击穿，则需要增加一只弓箭，即维护一个新的射击区间（将该气球击穿），随后继续遍历气球数组。
```


（2）代码实现

```go
func findMinArrowShots(points [][]int) int {
    n := len(points)
    if(n == 0){
        return 0
    }
    sort.Slice(points, func(i, j int) bool{
        return points[i][0] < points[j][0]      // 按照里层切片的左端元素从小到大排序
    })
    arrowNum := 1                           // 初始化弓箭数量
    var shotEnd int 
    shotEnd = points[0][1]    // 初始化射击区间，为第一个气球的两个端点
    for i := 1; i < n; i++ {
        if(points[i][0] <= shotEnd) {       // 当前点的左端与前一个点的右端有重合
            if(points[i][1] < shotEnd) {
                shotEnd = points[i][1]
            }
        }else {                            // 没有交集，弓箭数加1
            arrowNum++                      // 在保证当前气球被射穿的条件下，射击区间不能再更新了，需要增加一个新的射击区间
            shotEnd = points[i][1]
        }
    }
    return arrowNum
}
```

### 实现方式二：对气球数组的右侧坐标排序

（1）算法思路

解题思路：首先根据每个气球的后一个元素进行排序，
弓箭出发的坐标初始化为气球坐标的右端Xend；
如果气球的Xstart小于弓箭的坐标，那么这个气球就可以被弓箭穿过，进行下一次循环；
如果大于，需要增加一只弓箭并更新弓箭的坐标。


（2）代码实现
```go
func findMinArrowShots(points [][]int) int {
    n := len(points)
    if(n == 0){
        return 0
    }
    sort.Slice(points, func(i, j int) bool {    // 按照气球数组的右端进行从小到大排序
        return points[i][1] < points[j][1]
    })

    var arrowEnd int = points[0][1]             // 初始化弓箭右侧坐标为第一个气球的右端
    var arrowNum = 1
    for i := 1; i < n; i++ {
        if(points[i][0] > arrowEnd){            // 当前气球的左端大于弓箭的右端，增加一只弓箭，弓箭右侧坐标更新为当前气球的右端
            arrowNum++
            arrowEnd = points[i][1]
        }
    }
    return arrowNum
}
```