# 题目描述

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs

数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

示例 1:

输入: cost = [10, 15, 20]
输出: 15
解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
 示例 2:

输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。
注意：

cost 的长度将会在 [2, 1000]。
每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。

# 算法实现

这道题目表达的似乎不太清楚，造成不易理解，下面重新解读一下：
```markdown
1、每一个位置都有 2 个阶梯，1 个阶梯上一层楼，另 1 个阶梯上两层楼（可以理解为每个楼层都有左右两个楼梯，一个是通往上一层的，另一个是通往上两层的）；

2、上两个阶梯的体力值耗费是一样的，但是在不同位置消耗的体力值是不一样的；

3、楼层顶部在数组之外。如果数组长度为 len，那么楼顶就在索引为 len 这个位置。
```
简单地说，就是：
```markdown
这题主要是审题，理解题目的意思：

1.每个台阶对应一个消耗的体力值，也就是数组当前下标上的值。
2.每个台阶可以选择两种方式跳过去，跳一步，或者跳两步
3.最终跳完的，也就是怎么消耗最小的体力值，跳完这个楼梯。即每次选择跳的最小步数的值，因为只能选择挑一部或者跳两步，就是选择fn-1还是fn-2。

然后，比较fn-1和fn-2的值，也就是min(cost[n-1],cost[n-2]);
```

状态：dp[i] 表示到索引为 i 位置再选择向上爬一共需要的体力开销。

状态转移方程：
```markdown
dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i]
```
输出： min(dp[len - 1], dp[len - 2])。

说明：因为题目已经说了 cost 的长度将会在 [2, 1000]，因此，对数组 cost 的长度无需特判。

代码实现：
```go
func minCostClimbingStairs(cost []int) int {
    var f1, f2 int          // f1和f2分别表示当前楼层的上一个阶梯、上两个阶梯
    var curSum int
    for i := 0; i < len(cost); i++ {
        curSum = cost[i] + minInt(f1, f2)   // 当前第i层体力花费
        f2 = f1                             // f2后移一层，指向上一层的体力花费
        f1 = curSum                         // f1后移一层，指向当前层的体力花费
    }
    return minInt(f1, f2)                   // 楼层遍历结束，总体最小花费是前两层f1和f2中的最小值
}

func minInt(a, b int) int {
    if(a < b) {
        return a
    }
    return b
}
```

