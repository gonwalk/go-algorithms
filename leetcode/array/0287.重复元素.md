# 287. 寻找重复数

题目链接：https://leetcode-cn.com/problems/find-the-duplicate-number/
难易程度：中等

## 题目描述

给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。

示例 1:

输入: [1,3,4,2,2]
输出: 2
示例 2:

输入: [3,1,3,4,2]
输出: 3
说明：

不能更改原数组（假设数组是只读的）。
只能使用额外的 O(1) 的空间。
时间复杂度小于 O(n2) 。
数组中只有一个重复的数字，但它可能不止重复出现一次。


## 算法实现



证明 nums 中存在至少一个副本是鸽子洞原理的简单应用。这里，nums 中的每个数字都是一个 “鸽子”，nums 中可以出现的每个不同的数字都是一个 “鸽子洞”。因为有 n+1 个数是 n 个不同的可能数，鸽子洞原理意味着至少有一个数是重复的。

### 方法一：排序
如果对数字进行排序，则任何重复的数字都将与排序后的数组相邻。

算法：
算法相当简单。首先，我们对数组进行排序，然后将每个元素与前一个元素进行比较。因为数组中只有一个重复的元素，所以我们知道数组的长度至少为 2，一旦找到重复的元素，我们就可以返回它。

```Java
class Solution {
    public int findDuplicate(int[] nums) {
        Arrays.sort(nums);
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i-1]) {
                return nums[i];
            }
        }

        return -1;
    }
}
```
复杂度分析

时间复杂度：O(nlgn)。排序调用在 Golang、Python 和 Java 中花费 O(nlgn) 时间，因此它支配后续的线性扫描。
空间复杂度：O(1) (orO(n))，在这里，我们对 nums 进行排序，因此内存大小是恒定的。如果我们不能修改输入数组，那么我们必须为 nums 的副本分配线性空间，并对其进行排序。

### 方法二：使用map统计数组中每个元素出现的次数

// 使用map统计数组中每个元素出现的次数，以key表示nums中的每个元素，value表示该元素在nums数组中出现的次数
// 可以保证时间复杂度O(n)，但是空间复杂度O(n)还是比较高的，题目要求只能使用O(1)的空间复杂度


```go
func findDuplicate(nums []int) int {
    m := make(map[int]int, len(nums))
    for _, n := range nums {
        m[n] += 1
    }
    for _, num := range nums {
        if(m[num] >= 2) {
            return num
        }
    }
    return -1
}
```

### 方法三：快慢指针（可以同时满足时间O(n)和空间O(1)复杂度的要求）

如果我们对 nums 进行这样的解释，即对于每对索引i和值vi而言，“下一个” vj位于索引 vi处，我们可以将此问题减少到循环检测。

首先，我们可以很容易地证明问题的约束意味着必须存在一个循环。因为 nums 中的每个数字都在 1 和 n 之间，所以它必须指向存在的索引。此外，由于 0 不能作为 nums 中的值出现，nums[0] 不能作为循环的一部分。

这种解法跟链表寻找环一样，都是快慢指针，来判断是有环的，然后寻找到他们的相遇点，然后让low从0开始，fast从相遇点开始
这个时候速度设置为相同的速度。就可以找到入口了。

```go
func findDuplicate(nums []int) int { // 这种写法是标准的链表双指针寻找环的写法。
    low,fast := nums[0],nums[nums[0]]// 首先制定固有的速率，low是nums[low]的速度，fast是二倍于它的速度就是 nums[nums[0]]
    for low != fast {
        low = nums[low] // 按照不同的速度（存在倍数关系），如果这两者能相遇，就只有一个原因就是因为存在环。
        fast = nums[nums[fast]]
    }
    // 但是他们相遇的地方不一定是入口处，有可能是环的内部的某个元素，这个元素叫做相遇点。
    low = 0// 然后这一步我门要寻找这个环的入口，将low设置为0就是从头开始走，然后fast在相遇点。这个时候把他们的速度调成一样。
    // 即： low = nums[low] fast = nums[fast] 这样速度就一样了，（都是一次，之前速度不同的时候fast直接两次）
    for low != fast {
        low = nums[low]
        fast = nums[fast]
    }
    return low
}
```

### 方法四：二分查找法

抽屉原理：桌上有十个苹果，要把这十个苹果放到九个抽屉里，无论怎样放，我们会发现至少会有一个抽屉里面放不少于两个苹果。

思路：如果题目不限制：
```
1.不能更改原数组（假设数组是只读的）；
2.只能使用额外的 O(1) 的空间。
```

容易想到的方法有：
```
使用哈希表判重，这违反了限制 2；
将原始数组排序，排序以后，重复的数相邻，即找到了重复数，这违反了限制 1；
使用类似「力扣」第 41 题：“缺失的第一个正数” 的思路，当两个数发现要放在同一个地方的时候，就发现了这个重复的元素，这违反了限制 1；
既然要定位数，这个数恰好是一个整数，可以在“整数的有效范围内”做二分查找，但是比较恶心的一点是得反复看整个数组好几次，本文就介绍通过二分法定位数；
还可以使用“快慢指针”来完成，不过这种做法太有技巧性了，不是通用的做法，官方的题解就提供了这种做法。
```

方法：二分查找

思路：这道题要求我们查找的数是一个整数，并且给出了这个整数的范围（在 1 ~ n 之间，包括 1 和 n），并且给出了一些限制，于是可以使用二分查找法定位在一个区间里的整数。

这个问题应用二分法与绝大多数其它问题应用二分法的不同点是：正着思考是容易的，即思考哪边区间存在重复数是容易的，因为依然是有抽屉原理做保证。我们依然通过一个具体的例子来分析应该如何编写代码。

以 [1, 2, 2, 3, 4, 5, 6, 7] 为例，一共 8 个数，n + 1 = 8，n = 7，根据题目意思，每个数都在 1 和 7 之间。

例如：区间 [1, 7] 的中位数是 4，遍历整个数组，统计小于等于 4 的整数的个数，至多应该为 4 个。换句话说，整个数组里小于等于 4 的整数的个数如果严格大于 4 个，就说明重复的数存在于区间 [1, 4]，它的反面是：重复的数存在于区间 [5, 7]。

于是，二分法的思路是先猜一个数（有效范围 [left, right]里的中间数 mid），然后统计原始数组中小于等于这个中间数的元素的个数 cnt，如果 cnt 严格大于 mid，（注意我加了着重号的部分“小于等于”、“严格大于”）依然根据抽屉原理，重复元素就应该在区间 [left, mid] 里。

参考代码 1：
```Java
public class Solution {

    public int findDuplicate(int[] nums) {
        int len = nums.length;
        int left = 1;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            
            int cnt = 0;
            for (int num : nums) {
                if (num <= mid) {
                    cnt += 1;
                }
            }

            // 根据抽屉原理，小于等于 4 的个数如果严格大于 4 个
            // 此时重复元素一定出现在 [1, 4] 区间里

            if (cnt > mid) {
                // 重复元素位于区间 [left, mid]
                right = mid;
            } else {
                // if 分析正确了以后，else 搜索的区间就是 if 的反面
                // [mid + 1, right]
                left = mid + 1;
            }
        }
        return left;
    }
}
```

复杂度分析：

时间复杂度：O(NlogN)，二分法的时间复杂度为 O(logN)，在二分法的内部，执行了一次 for 循环，时间复杂度为 O(N)，故时间复杂度为 O(NlogN)。
空间复杂度：O(1)，使用了一个 cnt 变量，因此空间复杂度为 O(1)。
下面这一版写法有一点点小的不同。本质上与参考代码 1 没有区别，只是在一些边界的地方，供大家参考。

思路 2：（如果觉得下面的描述很拗口的话，举几个具体的例子，就很清楚了。）

先猜一个数（有效范围 [left, right]里的中间数 mid），然后统计原始数组中严格小于这个中间数的元素的个数 cnt，如果 cnt 大于等于 mid，（注意我加了着重号的部分“严格小于”、“大于等于”）依然根据抽屉原理，重复元素就应该在区间 [left, mid - 1] 里。

参考代码 2：
```Java
public class Solution {

    public int findDuplicate(int[] nums) {
        int len = nums.length;
        int left = 1;
        int right = len - 1;
        while (left < right) {
            int mid = (left + right + 1) >>> 1;

            int cnt = 0;
            for (int num : nums) {
                if (num < mid) {
                    cnt += 1;
                }
            }

            // 根据抽屉原理，严格小于 4 的数的个数如果大于等于 4 个，
            // 此时重复元素一定出现在 [1, 3] 区间里

            if (cnt >= mid) {
                // 重复的元素一定出现在 [left, mid - 1] 区间里
                right = mid - 1;
            } else {
                // if 分析正确了以后，else 搜索的区间就是 if 的反面
                // [mid, right]
                // 注意：此时需要调整中位数的取法为上取整
                left = mid;
            }
        }
        return left;
    }
}
```